# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


@dataclass
class IntermediateRepresentationSchemaIntegerTypeInformation:
    bits: 'int'
    size: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'IntermediateRepresentationSchemaIntegerTypeInformation':
        return cls(
            _from_json_data(int, data.get("bits")),
            _from_json_data(int, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["bits"] = _to_json_data(self.bits)
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class IntermediateRepresentationSchema:
    distinct_login_versions_other_than_all: 'List[int]'
    integer_type_information: 'Dict[str, IntermediateRepresentationSchemaIntegerTypeInformation]'
    login: 'Objects'
    login_version_opcodes: 'Dict[str, int]'
    tbc_update_mask: 'List[UpdateMask]'
    vanilla_update_mask: 'List[UpdateMask]'
    version: 'SchemaVersion'
    world: 'Objects'
    wrath_update_mask: 'List[UpdateMask]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'IntermediateRepresentationSchema':
        return cls(
            _from_json_data(List[int], data.get("distinct_login_versions_other_than_all")),
            _from_json_data(Dict[str, IntermediateRepresentationSchemaIntegerTypeInformation], data.get("integer_type_information")),
            _from_json_data(Objects, data.get("login")),
            _from_json_data(Dict[str, int], data.get("login_version_opcodes")),
            _from_json_data(List[UpdateMask], data.get("tbc_update_mask")),
            _from_json_data(List[UpdateMask], data.get("vanilla_update_mask")),
            _from_json_data(SchemaVersion, data.get("version")),
            _from_json_data(Objects, data.get("world")),
            _from_json_data(List[UpdateMask], data.get("wrath_update_mask")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["distinct_login_versions_other_than_all"] = _to_json_data(self.distinct_login_versions_other_than_all)
        data["integer_type_information"] = _to_json_data(self.integer_type_information)
        data["login"] = _to_json_data(self.login)
        data["login_version_opcodes"] = _to_json_data(self.login_version_opcodes)
        data["tbc_update_mask"] = _to_json_data(self.tbc_update_mask)
        data["vanilla_update_mask"] = _to_json_data(self.vanilla_update_mask)
        data["version"] = _to_json_data(self.version)
        data["world"] = _to_json_data(self.world)
        data["wrath_update_mask"] = _to_json_data(self.wrath_update_mask)
        return data

@dataclass
class ArraySize:
    array_size_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySize':
        variants: Dict[str, Type[ArraySize]] = {
            "Endless": ArraySizeEndless,
            "Fixed": ArraySizeFixed,
            "Variable": ArraySizeVariable,
        }

        return variants[data["array_size_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ArraySizeEndless(ArraySize):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySizeEndless':
        return cls(
            "Endless",
        )

    def to_json_data(self) -> Any:
        data = { "array_size_tag": "Endless" }
        return data

@dataclass
class ArraySizeFixed(ArraySize):
    size: 'str'
    """
    JSON Typedef does not support integers larger than unsigned 32 bit, so this
    is a string
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySizeFixed':
        return cls(
            "Fixed",
            _from_json_data(str, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data = { "array_size_tag": "Fixed" }
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class ArraySizeVariable(ArraySize):
    size: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySizeVariable':
        return cls(
            "Variable",
            _from_json_data(str, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data = { "array_size_tag": "Variable" }
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class ArrayType:
    array_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayType':
        variants: Dict[str, Type[ArrayType]] = {
            "CString": ArrayTypeCstring,
            "Guid": ArrayTypeGUID,
            "Integer": ArrayTypeInteger,
            "PackedGuid": ArrayTypePackedGUID,
            "Spell": ArrayTypeSpell,
            "Struct": ArrayTypeStruct,
        }

        return variants[data["array_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ArrayTypeCstring(ArrayType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeCstring':
        return cls(
            "CString",
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "CString" }
        return data

@dataclass
class ArrayTypeGUID(ArrayType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeGUID':
        return cls(
            "Guid",
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "Guid" }
        return data

@dataclass
class ArrayTypeInteger(ArrayType):
    integer_type: 'IntegerType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeInteger':
        return cls(
            "Integer",
            _from_json_data(IntegerType, data.get("integer_type")),
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "Integer" }
        data["integer_type"] = _to_json_data(self.integer_type)
        return data

@dataclass
class ArrayTypePackedGUID(ArrayType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypePackedGUID':
        return cls(
            "PackedGuid",
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "PackedGuid" }
        return data

@dataclass
class ArrayTypeSpell(ArrayType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeSpell':
        return cls(
            "Spell",
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "Spell" }
        return data

@dataclass
class ArrayTypeStruct(ArrayType):
    struct_data: 'Container'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeStruct':
        return cls(
            "Struct",
            _from_json_data(Container, data.get("struct_data")),
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "Struct" }
        data["struct_data"] = _to_json_data(self.struct_data)
        return data

@dataclass
class ByteTypeInnerType:
    byte_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteTypeInnerType':
        variants: Dict[str, Type[ByteTypeInnerType]] = {
            "Byte": ByteTypeInnerTypeByte,
            "Definer": ByteTypeInnerTypeDefiner,
        }

        return variants[data["byte_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ByteTypeInnerTypeByte(ByteTypeInnerType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteTypeInnerTypeByte':
        return cls(
            "Byte",
        )

    def to_json_data(self) -> Any:
        data = { "byte_type_tag": "Byte" }
        return data

@dataclass
class ByteTypeInnerTypeDefiner(ByteTypeInnerType):
    byte_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteTypeInnerTypeDefiner':
        return cls(
            "Definer",
            _from_json_data(str, data.get("byte_type")),
        )

    def to_json_data(self) -> Any:
        data = { "byte_type_tag": "Definer" }
        data["byte_type"] = _to_json_data(self.byte_type)
        return data

@dataclass
class ByteType:
    inner_type: 'ByteTypeInnerType'
    name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteType':
        return cls(
            _from_json_data(ByteTypeInnerType, data.get("inner_type")),
            _from_json_data(str, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["inner_type"] = _to_json_data(self.inner_type)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class Container:
    file_info: 'FileInfo'
    has_manual_size_field: 'bool'
    manual_size_subtraction: 'Optional[int]'
    members: 'List[StructMember]'
    name: 'str'
    object_type: 'ObjectType'
    only_has_io_error: 'bool'
    optional: 'Optional[OptionalMembers]'
    prepared_objects: 'List[PreparedObject]'
    """
    Is a structured representation of the object where fields that are inside
    if statements will be put inside the enumerators they are present in. This
    is used for example when wanting to represent conditionally present fields
    through e.g. discriminated unions or inheritance.
    """

    sizes: 'Sizes'
    tags: 'ObjectTags'
    tests: 'List[TestCase]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Container':
        return cls(
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(bool, data.get("has_manual_size_field")),
            _from_json_data(Optional[int], data.get("manual_size_subtraction")),
            _from_json_data(List[StructMember], data.get("members")),
            _from_json_data(str, data.get("name")),
            _from_json_data(ObjectType, data.get("object_type")),
            _from_json_data(bool, data.get("only_has_io_error")),
            _from_json_data(Optional[OptionalMembers], data.get("optional")),
            _from_json_data(List[PreparedObject], data.get("prepared_objects")),
            _from_json_data(Sizes, data.get("sizes")),
            _from_json_data(ObjectTags, data.get("tags")),
            _from_json_data(List[TestCase], data.get("tests")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["file_info"] = _to_json_data(self.file_info)
        data["has_manual_size_field"] = _to_json_data(self.has_manual_size_field)
        data["manual_size_subtraction"] = _to_json_data(self.manual_size_subtraction)
        data["members"] = _to_json_data(self.members)
        data["name"] = _to_json_data(self.name)
        data["object_type"] = _to_json_data(self.object_type)
        data["only_has_io_error"] = _to_json_data(self.only_has_io_error)
        data["optional"] = _to_json_data(self.optional)
        data["prepared_objects"] = _to_json_data(self.prepared_objects)
        data["sizes"] = _to_json_data(self.sizes)
        data["tags"] = _to_json_data(self.tags)
        data["tests"] = _to_json_data(self.tests)
        return data

@dataclass
class DataType:
    data_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataType':
        variants: Dict[str, Type[DataType]] = {
            "AchievementDoneArray": DataTypeAchievementDoneArray,
            "AchievementInProgressArray": DataTypeAchievementInProgressArray,
            "AddonArray": DataTypeAddonArray,
            "Array": DataTypeArray,
            "AuraMask": DataTypeAuraMask,
            "Bool": DataTypeBool,
            "CString": DataTypeCstring,
            "CacheMask": DataTypeCacheMask,
            "DateTime": DataTypeDateTime,
            "EnchantMask": DataTypeEnchantMask,
            "Enum": DataTypeEnum,
            "Flag": DataTypeFlag,
            "FloatingPoint": DataTypeFloatingPoint,
            "Gold": DataTypeGold,
            "Guid": DataTypeGUID,
            "InspectTalentGearMask": DataTypeInspectTalentGearMask,
            "Integer": DataTypeInteger,
            "IpAddress": DataTypeIPAddress,
            "Item": DataTypeItem,
            "Level": DataTypeLevel,
            "Level16": DataTypeLevel16,
            "Level32": DataTypeLevel32,
            "Milliseconds": DataTypeMilliseconds,
            "MonsterMoveSpline": DataTypeMonsterMoveSpline,
            "NamedGuid": DataTypeNamedGUID,
            "PackedGuid": DataTypePackedGUID,
            "Population": DataTypePopulation,
            "Seconds": DataTypeSeconds,
            "SizedCString": DataTypeSizedCstring,
            "Spell": DataTypeSpell,
            "Spell16": DataTypeSpell16,
            "String": DataTypeString,
            "Struct": DataTypeStruct,
            "UpdateMask": DataTypeUpdateMask,
            "VariableItemRandomProperty": DataTypeVariableItemRandomProperty,
        }

        return variants[data["data_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class DataTypeAchievementDoneArray(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAchievementDoneArray':
        return cls(
            "AchievementDoneArray",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AchievementDoneArray" }
        return data

@dataclass
class DataTypeAchievementInProgressArray(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAchievementInProgressArray':
        return cls(
            "AchievementInProgressArray",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AchievementInProgressArray" }
        return data

@dataclass
class DataTypeAddonArray(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAddonArray':
        return cls(
            "AddonArray",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AddonArray" }
        return data

@dataclass
class DataTypeArray(DataType):
    compressed: 'bool'
    inner_type: 'ArrayType'
    size: 'ArraySize'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeArray':
        return cls(
            "Array",
            _from_json_data(bool, data.get("compressed")),
            _from_json_data(ArrayType, data.get("inner_type")),
            _from_json_data(ArraySize, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Array" }
        data["compressed"] = _to_json_data(self.compressed)
        data["inner_type"] = _to_json_data(self.inner_type)
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class DataTypeAuraMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAuraMask':
        return cls(
            "AuraMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AuraMask" }
        return data

@dataclass
class DataTypeBool(DataType):
    integer_type: 'IntegerType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeBool':
        return cls(
            "Bool",
            _from_json_data(IntegerType, data.get("integer_type")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Bool" }
        data["integer_type"] = _to_json_data(self.integer_type)
        return data

@dataclass
class DataTypeCstring(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeCstring':
        return cls(
            "CString",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "CString" }
        return data

@dataclass
class DataTypeCacheMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeCacheMask':
        return cls(
            "CacheMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "CacheMask" }
        return data

@dataclass
class DataTypeDateTime(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeDateTime':
        return cls(
            "DateTime",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "DateTime" }
        return data

@dataclass
class DataTypeEnchantMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeEnchantMask':
        return cls(
            "EnchantMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "EnchantMask" }
        return data

@dataclass
class DataTypeEnum(DataType):
    integer_type: 'IntegerType'
    tags: 'ObjectTags'
    type_name: 'str'
    upcast: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeEnum':
        return cls(
            "Enum",
            _from_json_data(IntegerType, data.get("integer_type")),
            _from_json_data(ObjectTags, data.get("tags")),
            _from_json_data(str, data.get("type_name")),
            _from_json_data(bool, data.get("upcast")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Enum" }
        data["integer_type"] = _to_json_data(self.integer_type)
        data["tags"] = _to_json_data(self.tags)
        data["type_name"] = _to_json_data(self.type_name)
        data["upcast"] = _to_json_data(self.upcast)
        return data

@dataclass
class DataTypeFlag(DataType):
    integer_type: 'IntegerType'
    tags: 'ObjectTags'
    type_name: 'str'
    upcast: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeFlag':
        return cls(
            "Flag",
            _from_json_data(IntegerType, data.get("integer_type")),
            _from_json_data(ObjectTags, data.get("tags")),
            _from_json_data(str, data.get("type_name")),
            _from_json_data(bool, data.get("upcast")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Flag" }
        data["integer_type"] = _to_json_data(self.integer_type)
        data["tags"] = _to_json_data(self.tags)
        data["type_name"] = _to_json_data(self.type_name)
        data["upcast"] = _to_json_data(self.upcast)
        return data

@dataclass
class DataTypeFloatingPoint(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeFloatingPoint':
        return cls(
            "FloatingPoint",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "FloatingPoint" }
        return data

@dataclass
class DataTypeGold(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeGold':
        return cls(
            "Gold",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Gold" }
        return data

@dataclass
class DataTypeGUID(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeGUID':
        return cls(
            "Guid",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Guid" }
        return data

@dataclass
class DataTypeInspectTalentGearMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeInspectTalentGearMask':
        return cls(
            "InspectTalentGearMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "InspectTalentGearMask" }
        return data

@dataclass
class DataTypeInteger(DataType):
    integer_type: 'IntegerType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeInteger':
        return cls(
            "Integer",
            _from_json_data(IntegerType, data.get("integer_type")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Integer" }
        data["integer_type"] = _to_json_data(self.integer_type)
        return data

@dataclass
class DataTypeIPAddress(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeIPAddress':
        return cls(
            "IpAddress",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "IpAddress" }
        return data

@dataclass
class DataTypeItem(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeItem':
        return cls(
            "Item",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Item" }
        return data

@dataclass
class DataTypeLevel(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeLevel':
        return cls(
            "Level",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Level" }
        return data

@dataclass
class DataTypeLevel16(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeLevel16':
        return cls(
            "Level16",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Level16" }
        return data

@dataclass
class DataTypeLevel32(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeLevel32':
        return cls(
            "Level32",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Level32" }
        return data

@dataclass
class DataTypeMilliseconds(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeMilliseconds':
        return cls(
            "Milliseconds",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Milliseconds" }
        return data

@dataclass
class DataTypeMonsterMoveSpline(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeMonsterMoveSpline':
        return cls(
            "MonsterMoveSpline",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "MonsterMoveSpline" }
        return data

@dataclass
class DataTypeNamedGUID(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeNamedGUID':
        return cls(
            "NamedGuid",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "NamedGuid" }
        return data

@dataclass
class DataTypePackedGUID(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypePackedGUID':
        return cls(
            "PackedGuid",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "PackedGuid" }
        return data

@dataclass
class DataTypePopulation(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypePopulation':
        return cls(
            "Population",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Population" }
        return data

@dataclass
class DataTypeSeconds(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeSeconds':
        return cls(
            "Seconds",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Seconds" }
        return data

@dataclass
class DataTypeSizedCstring(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeSizedCstring':
        return cls(
            "SizedCString",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "SizedCString" }
        return data

@dataclass
class DataTypeSpell(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeSpell':
        return cls(
            "Spell",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Spell" }
        return data

@dataclass
class DataTypeSpell16(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeSpell16':
        return cls(
            "Spell16",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Spell16" }
        return data

@dataclass
class DataTypeString(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeString':
        return cls(
            "String",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "String" }
        return data

@dataclass
class DataTypeStruct(DataType):
    struct_data: 'Container'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeStruct':
        return cls(
            "Struct",
            _from_json_data(Container, data.get("struct_data")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Struct" }
        data["struct_data"] = _to_json_data(self.struct_data)
        return data

@dataclass
class DataTypeUpdateMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeUpdateMask':
        return cls(
            "UpdateMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "UpdateMask" }
        return data

@dataclass
class DataTypeVariableItemRandomProperty(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeVariableItemRandomProperty':
        return cls(
            "VariableItemRandomProperty",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "VariableItemRandomProperty" }
        return data

@dataclass
class DefinerObjectsUsedIn:
    definer_usage: 'DefinerUsage'
    object_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DefinerObjectsUsedIn':
        return cls(
            _from_json_data(DefinerUsage, data.get("definer_usage")),
            _from_json_data(str, data.get("object_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["definer_usage"] = _to_json_data(self.definer_usage)
        data["object_name"] = _to_json_data(self.object_name)
        return data

@dataclass
class Definer:
    definer_type: 'DefinerType'
    enumerators: 'List[Enumerator]'
    file_info: 'FileInfo'
    integer_type: 'IntegerType'
    name: 'str'
    objects_used_in: 'List[DefinerObjectsUsedIn]'
    tags: 'ObjectTags'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Definer':
        return cls(
            _from_json_data(DefinerType, data.get("definer_type")),
            _from_json_data(List[Enumerator], data.get("enumerators")),
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(IntegerType, data.get("integer_type")),
            _from_json_data(str, data.get("name")),
            _from_json_data(List[DefinerObjectsUsedIn], data.get("objects_used_in")),
            _from_json_data(ObjectTags, data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["definer_type"] = _to_json_data(self.definer_type)
        data["enumerators"] = _to_json_data(self.enumerators)
        data["file_info"] = _to_json_data(self.file_info)
        data["integer_type"] = _to_json_data(self.integer_type)
        data["name"] = _to_json_data(self.name)
        data["objects_used_in"] = _to_json_data(self.objects_used_in)
        data["tags"] = _to_json_data(self.tags)
        return data

class DefinerType(Enum):
    ENUM = "Enum"
    FLAG = "Flag"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DefinerType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class DefinerUsage(Enum):
    IN_IF_STATEMENT = "InIfStatement"
    REGULAR_USE = "RegularUse"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DefinerUsage':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Definition:
    constant_value: 'Optional[Value]'
    data_type: 'DataType'
    name: 'str'
    size_of_fields_before_size: 'Optional[int]'
    tags: 'MemberTags'
    used_as_size_in: 'Optional[str]'
    used_in_if: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Definition':
        return cls(
            _from_json_data(Optional[Value], data.get("constant_value")),
            _from_json_data(DataType, data.get("data_type")),
            _from_json_data(str, data.get("name")),
            _from_json_data(Optional[int], data.get("size_of_fields_before_size")),
            _from_json_data(MemberTags, data.get("tags")),
            _from_json_data(Optional[str], data.get("used_as_size_in")),
            _from_json_data(bool, data.get("used_in_if")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["constant_value"] = _to_json_data(self.constant_value)
        data["data_type"] = _to_json_data(self.data_type)
        data["name"] = _to_json_data(self.name)
        data["size_of_fields_before_size"] = _to_json_data(self.size_of_fields_before_size)
        data["tags"] = _to_json_data(self.tags)
        data["used_as_size_in"] = _to_json_data(self.used_as_size_in)
        data["used_in_if"] = _to_json_data(self.used_in_if)
        return data

@dataclass
class Enumerator:
    name: 'str'
    tags: 'MemberTags'
    value: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Enumerator':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(MemberTags, data.get("tags")),
            _from_json_data(Value, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        data["tags"] = _to_json_data(self.tags)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class FileInfo:
    end_position: 'int'
    file_name: 'str'
    start_position: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'FileInfo':
        return cls(
            _from_json_data(int, data.get("end_position")),
            _from_json_data(str, data.get("file_name")),
            _from_json_data(int, data.get("start_position")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["end_position"] = _to_json_data(self.end_position)
        data["file_name"] = _to_json_data(self.file_name)
        data["start_position"] = _to_json_data(self.start_position)
        return data

@dataclass
class FloatingPointValue:
    original_string: 'str'
    value: 'float'

    @classmethod
    def from_json_data(cls, data: Any) -> 'FloatingPointValue':
        return cls(
            _from_json_data(str, data.get("original_string")),
            _from_json_data(float, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["original_string"] = _to_json_data(self.original_string)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class IfStatement:
    definer_type: 'DefinerType'
    else_if_statements: 'List[IfStatement]'
    is_else_if_flag: 'bool'
    members: 'List[StructMember]'
    original_type: 'DataType'
    part_of_separate_if_statement: 'bool'
    values: 'List[str]'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'IfStatement':
        return cls(
            _from_json_data(DefinerType, data.get("definer_type")),
            _from_json_data(List[IfStatement], data.get("else_if_statements")),
            _from_json_data(bool, data.get("is_else_if_flag")),
            _from_json_data(List[StructMember], data.get("members")),
            _from_json_data(DataType, data.get("original_type")),
            _from_json_data(bool, data.get("part_of_separate_if_statement")),
            _from_json_data(List[str], data.get("values")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["definer_type"] = _to_json_data(self.definer_type)
        data["else_if_statements"] = _to_json_data(self.else_if_statements)
        data["is_else_if_flag"] = _to_json_data(self.is_else_if_flag)
        data["members"] = _to_json_data(self.members)
        data["original_type"] = _to_json_data(self.original_type)
        data["part_of_separate_if_statement"] = _to_json_data(self.part_of_separate_if_statement)
        data["values"] = _to_json_data(self.values)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

class IntegerType(Enum):
    I16 = "I16"
    I32 = "I32"
    I64 = "I64"
    I8 = "I8"
    U16 = "U16"
    U32 = "U32"
    U48 = "U48"
    U64 = "U64"
    U8 = "U8"
    @classmethod
    def from_json_data(cls, data: Any) -> 'IntegerType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class LoginVersions:
    login_version_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'LoginVersions':
        variants: Dict[str, Type[LoginVersions]] = {
            "all": LoginVersionsAll,
            "specific": LoginVersionsSpecific,
        }

        return variants[data["login_version_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class LoginVersionsAll(LoginVersions):

    @classmethod
    def from_json_data(cls, data: Any) -> 'LoginVersionsAll':
        return cls(
            "all",
        )

    def to_json_data(self) -> Any:
        data = { "login_version_tag": "all" }
        return data

@dataclass
class LoginVersionsSpecific(LoginVersions):
    versions: 'List[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'LoginVersionsSpecific':
        return cls(
            "specific",
            _from_json_data(List[int], data.get("versions")),
        )

    def to_json_data(self) -> Any:
        data = { "login_version_tag": "specific" }
        data["versions"] = _to_json_data(self.versions)
        return data

@dataclass
class MemberTagsValidRange:
    """
    JSON Typedef does not support integers larger than unsigned 32 bit, so this
    is a string
    """

    from_: 'str'
    to: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MemberTagsValidRange':
        return cls(
            _from_json_data(str, data.get("from")),
            _from_json_data(str, data.get("to")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["from"] = _to_json_data(self.from_)
        data["to"] = _to_json_data(self.to)
        return data

@dataclass
class MemberTags:
    comment: 'Optional[str]'
    display: 'Optional[str]'
    maximum_length: 'Optional[str]'
    """
    JSON Typedef does not support integers larger than unsigned 32 bit, so this
    is a string
    """

    valid_range: 'Optional[MemberTagsValidRange]'
    """
    JSON Typedef does not support integers larger than unsigned 32 bit, so this
    is a string
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'MemberTags':
        return cls(
            _from_json_data(Optional[str], data.get("comment")),
            _from_json_data(Optional[str], data.get("display")),
            _from_json_data(Optional[str], data.get("maximum_length")),
            _from_json_data(Optional[MemberTagsValidRange], data.get("valid_range")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.comment is not None:
             data["comment"] = _to_json_data(self.comment)
        if self.display is not None:
             data["display"] = _to_json_data(self.display)
        if self.maximum_length is not None:
             data["maximum_length"] = _to_json_data(self.maximum_length)
        if self.valid_range is not None:
             data["valid_range"] = _to_json_data(self.valid_range)
        return data

@dataclass
class ObjectTags:
    version: 'ObjectVersions'
    comment: 'Optional[str]'
    compressed: 'Optional[bool]'
    non_network_type: 'Optional[bool]'
    unimplemented: 'Optional[bool]'
    used_in_update_mask: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTags':
        return cls(
            _from_json_data(ObjectVersions, data.get("version")),
            _from_json_data(Optional[str], data.get("comment")),
            _from_json_data(Optional[bool], data.get("compressed")),
            _from_json_data(Optional[bool], data.get("non_network_type")),
            _from_json_data(Optional[bool], data.get("unimplemented")),
            _from_json_data(Optional[bool], data.get("used_in_update_mask")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["version"] = _to_json_data(self.version)
        if self.comment is not None:
             data["comment"] = _to_json_data(self.comment)
        if self.compressed is not None:
             data["compressed"] = _to_json_data(self.compressed)
        if self.non_network_type is not None:
             data["non_network_type"] = _to_json_data(self.non_network_type)
        if self.unimplemented is not None:
             data["unimplemented"] = _to_json_data(self.unimplemented)
        if self.used_in_update_mask is not None:
             data["used_in_update_mask"] = _to_json_data(self.used_in_update_mask)
        return data

@dataclass
class ObjectType:
    container_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectType':
        variants: Dict[str, Type[ObjectType]] = {
            "CLogin": ObjectTypeClogin,
            "CMsg": ObjectTypeCmsg,
            "Msg": ObjectTypeMsg,
            "SLogin": ObjectTypeSlogin,
            "SMsg": ObjectTypeSmsg,
            "Struct": ObjectTypeStruct,
        }

        return variants[data["container_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ObjectTypeClogin(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeClogin':
        return cls(
            "CLogin",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "CLogin" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeCmsg(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeCmsg':
        return cls(
            "CMsg",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "CMsg" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeMsg(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeMsg':
        return cls(
            "Msg",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "Msg" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeSlogin(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeSlogin':
        return cls(
            "SLogin",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "SLogin" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeSmsg(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeSmsg':
        return cls(
            "SMsg",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "SMsg" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeStruct(ObjectType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeStruct':
        return cls(
            "Struct",
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "Struct" }
        return data

@dataclass
class ObjectVersions:
    version_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectVersions':
        variants: Dict[str, Type[ObjectVersions]] = {
            "login": ObjectVersionsLogin,
            "world": ObjectVersionsWorld,
        }

        return variants[data["version_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ObjectVersionsLogin(ObjectVersions):
    version_type: 'LoginVersions'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectVersionsLogin':
        return cls(
            "login",
            _from_json_data(LoginVersions, data.get("version_type")),
        )

    def to_json_data(self) -> Any:
        data = { "version_type_tag": "login" }
        data["version_type"] = _to_json_data(self.version_type)
        return data

@dataclass
class ObjectVersionsWorld(ObjectVersions):
    version_type: 'WorldVersions'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectVersionsWorld':
        return cls(
            "world",
            _from_json_data(WorldVersions, data.get("version_type")),
        )

    def to_json_data(self) -> Any:
        data = { "version_type_tag": "world" }
        data["version_type"] = _to_json_data(self.version_type)
        return data

@dataclass
class Objects:
    enums: 'List[Definer]'
    flags: 'List[Definer]'
    messages: 'List[Container]'
    structs: 'List[Container]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Objects':
        return cls(
            _from_json_data(List[Definer], data.get("enums")),
            _from_json_data(List[Definer], data.get("flags")),
            _from_json_data(List[Container], data.get("messages")),
            _from_json_data(List[Container], data.get("structs")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enums"] = _to_json_data(self.enums)
        data["flags"] = _to_json_data(self.flags)
        data["messages"] = _to_json_data(self.messages)
        data["structs"] = _to_json_data(self.structs)
        return data

@dataclass
class OptionalMembers:
    members: 'List[StructMember]'
    name: 'str'
    prepared_objects: 'List[PreparedObject]'
    """
    Is a structured representation of the object where fields that are inside
    if statements will be put inside the enumerators they are present in. This
    is used for example when wanting to represent conditionally present fields
    through e.g. discriminated unions or inheritance.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OptionalMembers':
        return cls(
            _from_json_data(List[StructMember], data.get("members")),
            _from_json_data(str, data.get("name")),
            _from_json_data(List[PreparedObject], data.get("prepared_objects")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["members"] = _to_json_data(self.members)
        data["name"] = _to_json_data(self.name)
        data["prepared_objects"] = _to_json_data(self.prepared_objects)
        return data

@dataclass
class PreparedObject:
    """
    Represents a field in the object, and the fields for each enumerator if it's
    an enum/flag.
    """

    enum_part_of_separate_statements: 'bool'
    is_elseif_flag: 'bool'
    name: 'str'
    """
    Name inside the object. Search through the original object to get type and
    other information.
    """

    definer_type: 'Optional[DefinerType]'
    enumerators: 'Optional[Dict[str, List[PreparedObject]]]'
    """
    If this is present the field contains other fields.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'PreparedObject':
        return cls(
            _from_json_data(bool, data.get("enum_part_of_separate_statements")),
            _from_json_data(bool, data.get("is_elseif_flag")),
            _from_json_data(str, data.get("name")),
            _from_json_data(Optional[DefinerType], data.get("definer_type")),
            _from_json_data(Optional[Dict[str, List[PreparedObject]]], data.get("enumerators")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enum_part_of_separate_statements"] = _to_json_data(self.enum_part_of_separate_statements)
        data["is_elseif_flag"] = _to_json_data(self.is_elseif_flag)
        data["name"] = _to_json_data(self.name)
        if self.definer_type is not None:
             data["definer_type"] = _to_json_data(self.definer_type)
        if self.enumerators is not None:
             data["enumerators"] = _to_json_data(self.enumerators)
        return data

@dataclass
class SchemaVersion:
    major: 'int'
    minor: 'int'
    patch: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SchemaVersion':
        return cls(
            _from_json_data(int, data.get("major")),
            _from_json_data(int, data.get("minor")),
            _from_json_data(int, data.get("patch")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["major"] = _to_json_data(self.major)
        data["minor"] = _to_json_data(self.minor)
        data["patch"] = _to_json_data(self.patch)
        return data

@dataclass
class Sizes:
    constant_sized: 'bool'
    maximum_size: 'int'
    minimum_size: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Sizes':
        return cls(
            _from_json_data(bool, data.get("constant_sized")),
            _from_json_data(int, data.get("maximum_size")),
            _from_json_data(int, data.get("minimum_size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["constant_sized"] = _to_json_data(self.constant_sized)
        data["maximum_size"] = _to_json_data(self.maximum_size)
        data["minimum_size"] = _to_json_data(self.minimum_size)
        return data

@dataclass
class StructMember:
    struct_member_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StructMember':
        variants: Dict[str, Type[StructMember]] = {
            "Definition": StructMemberDefinition,
            "IfStatement": StructMemberIfStatement,
        }

        return variants[data["struct_member_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class StructMemberDefinition(StructMember):
    struct_member_content: 'Definition'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StructMemberDefinition':
        return cls(
            "Definition",
            _from_json_data(Definition, data.get("struct_member_content")),
        )

    def to_json_data(self) -> Any:
        data = { "struct_member_tag": "Definition" }
        data["struct_member_content"] = _to_json_data(self.struct_member_content)
        return data

@dataclass
class StructMemberIfStatement(StructMember):
    struct_member_content: 'IfStatement'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StructMemberIfStatement':
        return cls(
            "IfStatement",
            _from_json_data(IfStatement, data.get("struct_member_content")),
        )

    def to_json_data(self) -> Any:
        data = { "struct_member_tag": "IfStatement" }
        data["struct_member_content"] = _to_json_data(self.struct_member_content)
        return data

@dataclass
class TestCase:
    file_info: 'FileInfo'
    members: 'List[TestCaseMember]'
    raw_bytes: 'List[int]'
    subject: 'str'
    tags: 'ObjectTags'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCase':
        return cls(
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(List[TestCaseMember], data.get("members")),
            _from_json_data(List[int], data.get("raw_bytes")),
            _from_json_data(str, data.get("subject")),
            _from_json_data(ObjectTags, data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["file_info"] = _to_json_data(self.file_info)
        data["members"] = _to_json_data(self.members)
        data["raw_bytes"] = _to_json_data(self.raw_bytes)
        data["subject"] = _to_json_data(self.subject)
        data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class TestCaseMember:
    tags: 'MemberTags'
    value: 'TestCaseValue'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseMember':
        return cls(
            _from_json_data(MemberTags, data.get("tags")),
            _from_json_data(TestCaseValue, data.get("value")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["tags"] = _to_json_data(self.tags)
        data["value"] = _to_json_data(self.value)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

@dataclass
class TestCaseValue:
    test_value_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValue':
        variants: Dict[str, Type[TestCaseValue]] = {
            "Array": TestCaseValueArray,
            "ArrayOfSubObject": TestCaseValueArrayOfSubObject,
            "Bool": TestCaseValueBool,
            "DateTime": TestCaseValueDateTime,
            "Enum": TestCaseValueEnum,
            "Flag": TestCaseValueFlag,
            "FloatingPoint": TestCaseValueFloatingPoint,
            "Gold": TestCaseValueGold,
            "Guid": TestCaseValueGUID,
            "Integer": TestCaseValueInteger,
            "IpAddress": TestCaseValueIPAddress,
            "Level": TestCaseValueLevel,
            "Milliseconds": TestCaseValueMilliseconds,
            "MonsterMoveSpline": TestCaseValueMonsterMoveSpline,
            "Population": TestCaseValuePopulation,
            "Seconds": TestCaseValueSeconds,
            "String": TestCaseValueString,
            "SubObject": TestCaseValueSubObject,
            "UpdateMask": TestCaseValueUpdateMask,
        }

        return variants[data["test_value_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class TestCaseValueArrayContent:
    size: 'ArraySize'
    values: 'List[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArrayContent':
        return cls(
            _from_json_data(ArraySize, data.get("size")),
            _from_json_data(List[str], data.get("values")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["size"] = _to_json_data(self.size)
        data["values"] = _to_json_data(self.values)
        return data

@dataclass
class TestCaseValueArray(TestCaseValue):
    content: 'TestCaseValueArrayContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArray':
        return cls(
            "Array",
            _from_json_data(TestCaseValueArrayContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Array" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueArrayOfSubObjectContent:
    members: 'List[List[TestCaseMember]]'
    size: 'ArraySize'
    type_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArrayOfSubObjectContent':
        return cls(
            _from_json_data(List[List[TestCaseMember]], data.get("members")),
            _from_json_data(ArraySize, data.get("size")),
            _from_json_data(str, data.get("type_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["members"] = _to_json_data(self.members)
        data["size"] = _to_json_data(self.size)
        data["type_name"] = _to_json_data(self.type_name)
        return data

@dataclass
class TestCaseValueArrayOfSubObject(TestCaseValue):
    content: 'TestCaseValueArrayOfSubObjectContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArrayOfSubObject':
        return cls(
            "ArrayOfSubObject",
            _from_json_data(TestCaseValueArrayOfSubObjectContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "ArrayOfSubObject" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueBool(TestCaseValue):
    content: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueBool':
        return cls(
            "Bool",
            _from_json_data(bool, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Bool" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueDateTime(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueDateTime':
        return cls(
            "DateTime",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "DateTime" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueEnum(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueEnum':
        return cls(
            "Enum",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Enum" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueFlag(TestCaseValue):
    content: 'List[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueFlag':
        return cls(
            "Flag",
            _from_json_data(List[str], data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Flag" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueFloatingPoint(TestCaseValue):
    content: 'FloatingPointValue'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueFloatingPoint':
        return cls(
            "FloatingPoint",
            _from_json_data(FloatingPointValue, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "FloatingPoint" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueGold(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueGold':
        return cls(
            "Gold",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Gold" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueGUID(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueGUID':
        return cls(
            "Guid",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Guid" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueInteger(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueInteger':
        return cls(
            "Integer",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Integer" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueIPAddress(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueIPAddress':
        return cls(
            "IpAddress",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "IpAddress" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueLevel(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueLevel':
        return cls(
            "Level",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Level" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueMilliseconds(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueMilliseconds':
        return cls(
            "Milliseconds",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Milliseconds" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueMonsterMoveSplineContent:
    x: 'float'
    y: 'float'
    z: 'float'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueMonsterMoveSplineContent':
        return cls(
            _from_json_data(float, data.get("x")),
            _from_json_data(float, data.get("y")),
            _from_json_data(float, data.get("z")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["x"] = _to_json_data(self.x)
        data["y"] = _to_json_data(self.y)
        data["z"] = _to_json_data(self.z)
        return data

@dataclass
class TestCaseValueMonsterMoveSpline(TestCaseValue):
    content: 'List[TestCaseValueMonsterMoveSplineContent]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueMonsterMoveSpline':
        return cls(
            "MonsterMoveSpline",
            _from_json_data(List[TestCaseValueMonsterMoveSplineContent], data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "MonsterMoveSpline" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValuePopulation(TestCaseValue):
    content: 'float'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValuePopulation':
        return cls(
            "Population",
            _from_json_data(float, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Population" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueSeconds(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueSeconds':
        return cls(
            "Seconds",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Seconds" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueString(TestCaseValue):
    content: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueString':
        return cls(
            "String",
            _from_json_data(str, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "String" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueSubObjectContent:
    members: 'List[TestCaseMember]'
    type_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueSubObjectContent':
        return cls(
            _from_json_data(List[TestCaseMember], data.get("members")),
            _from_json_data(str, data.get("type_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["members"] = _to_json_data(self.members)
        data["type_name"] = _to_json_data(self.type_name)
        return data

@dataclass
class TestCaseValueSubObject(TestCaseValue):
    content: 'TestCaseValueSubObjectContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueSubObject':
        return cls(
            "SubObject",
            _from_json_data(TestCaseValueSubObjectContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "SubObject" }
        data["content"] = _to_json_data(self.content)
        return data

class TestCaseValueUpdateMaskContentUpdateMaskType(Enum):
    CONTAINER = "Container"
    CORPSE = "Corpse"
    DYNAMIC_OBJECT = "DynamicObject"
    GAME_OBJECT = "GameObject"
    ITEM = "Item"
    OBJECT = "Object"
    PLAYER = "Player"
    UNIT = "Unit"
    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueUpdateMaskContentUpdateMaskType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class TestCaseValueUpdateMaskContent:
    update_mask_name: 'str'
    update_mask_type: 'TestCaseValueUpdateMaskContentUpdateMaskType'
    update_mask_value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueUpdateMaskContent':
        return cls(
            _from_json_data(str, data.get("update_mask_name")),
            _from_json_data(TestCaseValueUpdateMaskContentUpdateMaskType, data.get("update_mask_type")),
            _from_json_data(str, data.get("update_mask_value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["update_mask_name"] = _to_json_data(self.update_mask_name)
        data["update_mask_type"] = _to_json_data(self.update_mask_type)
        data["update_mask_value"] = _to_json_data(self.update_mask_value)
        return data

@dataclass
class TestCaseValueUpdateMask(TestCaseValue):
    content: 'List[TestCaseValueUpdateMaskContent]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueUpdateMask':
        return cls(
            "UpdateMask",
            _from_json_data(List[TestCaseValueUpdateMaskContent], data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "UpdateMask" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TwoShortTypeInnerType:
    two_short_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TwoShortTypeInnerType':
        variants: Dict[str, Type[TwoShortTypeInnerType]] = {
            "Definer": TwoShortTypeInnerTypeDefiner,
            "Short": TwoShortTypeInnerTypeShort,
        }

        return variants[data["two_short_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class TwoShortTypeInnerTypeDefiner(TwoShortTypeInnerType):
    two_short_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TwoShortTypeInnerTypeDefiner':
        return cls(
            "Definer",
            _from_json_data(str, data.get("two_short_type")),
        )

    def to_json_data(self) -> Any:
        data = { "two_short_type_tag": "Definer" }
        data["two_short_type"] = _to_json_data(self.two_short_type)
        return data

@dataclass
class TwoShortTypeInnerTypeShort(TwoShortTypeInnerType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TwoShortTypeInnerTypeShort':
        return cls(
            "Short",
        )

    def to_json_data(self) -> Any:
        data = { "two_short_type_tag": "Short" }
        return data

@dataclass
class TwoShortType:
    inner_type: 'TwoShortTypeInnerType'
    name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TwoShortType':
        return cls(
            _from_json_data(TwoShortTypeInnerType, data.get("inner_type")),
            _from_json_data(str, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["inner_type"] = _to_json_data(self.inner_type)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class UpdateMaskDataType:
    update_mask_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataType':
        variants: Dict[str, Type[UpdateMaskDataType]] = {
            "ArrayOfStruct": UpdateMaskDataTypeArrayOfStruct,
            "Bytes": UpdateMaskDataTypeBytes,
            "Float": UpdateMaskDataTypeFloat,
            "Guid": UpdateMaskDataTypeGUID,
            "GuidArrayUsingEnum": UpdateMaskDataTypeGUIDArrayUsingEnum,
            "Int": UpdateMaskDataTypeInt,
            "TwoShort": UpdateMaskDataTypeTwoShort,
        }

        return variants[data["update_mask_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class UpdateMaskDataTypeArrayOfStructContent:
    size: 'int'
    update_mask_struct: 'UpdateMaskStruct'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeArrayOfStructContent':
        return cls(
            _from_json_data(int, data.get("size")),
            _from_json_data(UpdateMaskStruct, data.get("update_mask_struct")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["size"] = _to_json_data(self.size)
        data["update_mask_struct"] = _to_json_data(self.update_mask_struct)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

@dataclass
class UpdateMaskDataTypeArrayOfStruct(UpdateMaskDataType):
    content: 'UpdateMaskDataTypeArrayOfStructContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeArrayOfStruct':
        return cls(
            "ArrayOfStruct",
            _from_json_data(UpdateMaskDataTypeArrayOfStructContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "ArrayOfStruct" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class UpdateMaskDataTypeBytesContent:
    first: 'ByteType'
    fourth: 'ByteType'
    second: 'ByteType'
    third: 'ByteType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeBytesContent':
        return cls(
            _from_json_data(ByteType, data.get("first")),
            _from_json_data(ByteType, data.get("fourth")),
            _from_json_data(ByteType, data.get("second")),
            _from_json_data(ByteType, data.get("third")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["first"] = _to_json_data(self.first)
        data["fourth"] = _to_json_data(self.fourth)
        data["second"] = _to_json_data(self.second)
        data["third"] = _to_json_data(self.third)
        return data

@dataclass
class UpdateMaskDataTypeBytes(UpdateMaskDataType):
    content: 'UpdateMaskDataTypeBytesContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeBytes':
        return cls(
            "Bytes",
            _from_json_data(UpdateMaskDataTypeBytesContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Bytes" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class UpdateMaskDataTypeFloat(UpdateMaskDataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeFloat':
        return cls(
            "Float",
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Float" }
        return data

@dataclass
class UpdateMaskDataTypeGUID(UpdateMaskDataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeGUID':
        return cls(
            "Guid",
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Guid" }
        return data

@dataclass
class UpdateMaskDataTypeGUIDArrayUsingEnumContent:
    definer: 'Definer'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeGUIDArrayUsingEnumContent':
        return cls(
            _from_json_data(Definer, data.get("definer")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["definer"] = _to_json_data(self.definer)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

@dataclass
class UpdateMaskDataTypeGUIDArrayUsingEnum(UpdateMaskDataType):
    content: 'UpdateMaskDataTypeGUIDArrayUsingEnumContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeGUIDArrayUsingEnum':
        return cls(
            "GuidArrayUsingEnum",
            _from_json_data(UpdateMaskDataTypeGUIDArrayUsingEnumContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "GuidArrayUsingEnum" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class UpdateMaskDataTypeInt(UpdateMaskDataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeInt':
        return cls(
            "Int",
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Int" }
        return data

@dataclass
class UpdateMaskDataTypeTwoShortContent:
    first: 'TwoShortType'
    second: 'TwoShortType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeTwoShortContent':
        return cls(
            _from_json_data(TwoShortType, data.get("first")),
            _from_json_data(TwoShortType, data.get("second")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["first"] = _to_json_data(self.first)
        data["second"] = _to_json_data(self.second)
        return data

@dataclass
class UpdateMaskDataTypeTwoShort(UpdateMaskDataType):
    content: 'UpdateMaskDataTypeTwoShortContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeTwoShort':
        return cls(
            "TwoShort",
            _from_json_data(UpdateMaskDataTypeTwoShortContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "TwoShort" }
        data["content"] = _to_json_data(self.content)
        return data

class UpdateMaskObjectType(Enum):
    CONTAINER = "Container"
    CORPSE = "Corpse"
    DYNAMIC_OBJECT = "DynamicObject"
    GAME_OBJECT = "GameObject"
    ITEM = "Item"
    OBJECT = "Object"
    PLAYER = "Player"
    UNIT = "Unit"
    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskObjectType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class UpdateMask:
    data_type: 'UpdateMaskDataType'
    name: 'str'
    object_type: 'UpdateMaskObjectType'
    offset: 'int'
    size: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMask':
        return cls(
            _from_json_data(UpdateMaskDataType, data.get("data_type")),
            _from_json_data(str, data.get("name")),
            _from_json_data(UpdateMaskObjectType, data.get("object_type")),
            _from_json_data(int, data.get("offset")),
            _from_json_data(int, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["data_type"] = _to_json_data(self.data_type)
        data["name"] = _to_json_data(self.name)
        data["object_type"] = _to_json_data(self.object_type)
        data["offset"] = _to_json_data(self.offset)
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class UpdateMaskStructMember:
    member: 'Definition'
    offset: 'int'
    size: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskStructMember':
        return cls(
            _from_json_data(Definition, data.get("member")),
            _from_json_data(int, data.get("offset")),
            _from_json_data(int, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["member"] = _to_json_data(self.member)
        data["offset"] = _to_json_data(self.offset)
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class UpdateMaskStruct:
    file_info: 'FileInfo'
    members: 'List[List[UpdateMaskStructMember]]'
    name: 'str'
    sizes: 'Sizes'
    tags: 'ObjectTags'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskStruct':
        return cls(
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(List[List[UpdateMaskStructMember]], data.get("members")),
            _from_json_data(str, data.get("name")),
            _from_json_data(Sizes, data.get("sizes")),
            _from_json_data(ObjectTags, data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["file_info"] = _to_json_data(self.file_info)
        data["members"] = _to_json_data(self.members)
        data["name"] = _to_json_data(self.name)
        data["sizes"] = _to_json_data(self.sizes)
        data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class Value:
    original_string: 'str'
    value: 'str'
    """
    JSON Typedef does not support integers larger than unsigned 32 bit, so this
    is a string
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Value':
        return cls(
            _from_json_data(str, data.get("original_string")),
            _from_json_data(str, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["original_string"] = _to_json_data(self.original_string)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class WorldVersion:
    build: 'Optional[int]'
    major: 'int'
    minor: 'Optional[int]'
    patch: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersion':
        return cls(
            _from_json_data(Optional[int], data.get("build")),
            _from_json_data(int, data.get("major")),
            _from_json_data(Optional[int], data.get("minor")),
            _from_json_data(Optional[int], data.get("patch")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["build"] = _to_json_data(self.build)
        data["major"] = _to_json_data(self.major)
        data["minor"] = _to_json_data(self.minor)
        data["patch"] = _to_json_data(self.patch)
        return data

@dataclass
class WorldVersions:
    world_version_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersions':
        variants: Dict[str, Type[WorldVersions]] = {
            "all": WorldVersionsAll,
            "specific": WorldVersionsSpecific,
        }

        return variants[data["world_version_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class WorldVersionsAll(WorldVersions):

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersionsAll':
        return cls(
            "all",
        )

    def to_json_data(self) -> Any:
        data = { "world_version_tag": "all" }
        return data

@dataclass
class WorldVersionsSpecific(WorldVersions):
    versions: 'List[WorldVersion]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersionsSpecific':
        return cls(
            "specific",
            _from_json_data(List[WorldVersion], data.get("versions")),
        )

    def to_json_data(self) -> Any:
        data = { "world_version_tag": "specific" }
        data["versions"] = _to_json_data(self.versions)
        return data

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = r'^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
