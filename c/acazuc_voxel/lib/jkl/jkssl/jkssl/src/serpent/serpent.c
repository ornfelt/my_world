#include "serpent/serpent.h"
#include "utils/utils.h"

#include <string.h>

static const uint8_t sbox[8][16] =
{
	{
		0x3, 0x8, 0xF, 0x1, 0xA, 0x6, 0x5, 0xB,
		0xE, 0xD, 0x4, 0x2, 0x7, 0x0, 0x9, 0xC,
	},
	{
		0xF, 0xC, 0x2, 0x7, 0x9, 0x0, 0x5, 0xA,
		0x1, 0xB, 0xE, 0x8, 0x6, 0xD, 0x3, 0x4,
	},
	{
		0x8, 0x6, 0x7, 0x9, 0x3, 0xC, 0xA, 0xF,
		0xD, 0x1, 0xE, 0x4, 0x0, 0xB, 0x5, 0x2,
	},
	{
		0x0, 0xF, 0xB, 0x8, 0xC, 0x9, 0x6, 0x3,
		0xD, 0x1, 0x2, 0x4, 0xA, 0x7, 0x5, 0xE,
	},
	{
		0x1, 0xF, 0x8, 0x3, 0xC, 0x0, 0xB, 0x6,
		0x2, 0x5, 0x4, 0xA, 0x9, 0xE, 0x7, 0xD,
	},
	{
		0xF, 0x5, 0x2, 0xB, 0x4, 0xA, 0x9, 0xC,
		0x0, 0x3, 0xE, 0x8, 0xD, 0x6, 0x7, 0x1,
	},
	{
		0x7, 0x2, 0xC, 0x5, 0x8, 0x4, 0x6, 0xB,
		0xE, 0x9, 0x1, 0xF, 0xD, 0x3, 0xA, 0x0,
	},
	{
		0x1, 0xD, 0xF, 0x0, 0xE, 0x8, 0x2, 0xB,
		0x7, 0x4, 0xC, 0xA, 0x9, 0x3, 0x5, 0x6,
	},
};

static const uint8_t inv_sbox[8][16] =
{
	{
		0xD, 0x3, 0xB, 0x0, 0xA, 0x6, 0x5, 0xC,
		0x1, 0xE, 0x4, 0x7, 0xF, 0x9, 0x8, 0x2,
	},
	{
		0x5, 0x8, 0x2, 0xE, 0xF, 0x6, 0xC, 0x3,
		0xB, 0x4, 0x7, 0x9, 0x1, 0xD, 0xA, 0x0,
	},
	{
		0xC, 0x9, 0xF, 0x4, 0xB, 0xE, 0x1, 0x2,
		0x0, 0x3, 0x6, 0xD, 0x5, 0x8, 0xA, 0x7,
	},
	{
		0x0, 0x9, 0xA, 0x7, 0xB, 0xE, 0x6, 0xD,
		0x3, 0x5, 0xC, 0x2, 0x4, 0x8, 0xF, 0x1,
	},
	{
		0x5, 0x0, 0x8, 0x3, 0xA, 0x9, 0x7, 0xE,
		0x2, 0xC, 0xB, 0x6, 0x4, 0xF, 0xD, 0x1,
	},
	{
		0x8, 0xF, 0x2, 0x9, 0x4, 0x1, 0xD, 0xE,
		0xB, 0x6, 0x5, 0x3, 0x7, 0xC, 0xA, 0x0,
	},
	{
		0xF, 0xA, 0x1, 0xD, 0x5, 0x3, 0x6, 0x0,
		0x4, 0x9, 0xE, 0x7, 0x2, 0xC, 0x8, 0xB,
	},
	{
		0x3, 0x0, 0x6, 0xD, 0x9, 0xE, 0xF, 0x8,
		0x5, 0xC, 0xB, 0x7, 0xA, 0x1, 0x4, 0x2,
	},
};

static void substitute(uint32_t *dst, uint32_t *src, const uint8_t *sbox_ptr)
{
	dst[0] = 0;
	dst[1] = 0;
	dst[2] = 0;
	dst[3] = 0;
	for (size_t j = 0; j < 32; ++j)
	{
		uint8_t sidx;
		sidx  = ((src[0] >> j) & 1) << 0;
		sidx |= ((src[1] >> j) & 1) << 1;
		sidx |= ((src[2] >> j) & 1) << 2;
		sidx |= ((src[3] >> j) & 1) << 3;
		uint8_t v = sbox_ptr[sidx];
		dst[0] |= ((v >> 0) & 1) << j;
		dst[1] |= ((v >> 1) & 1) << j;
		dst[2] |= ((v >> 2) & 1) << j;
		dst[3] |= ((v >> 3) & 1) << j;
	}
}

void serpent_encrypt(struct serpent_ctx *ctx, uint8_t *out, const uint8_t *in)
{
	uint32_t tmp1[4];
	uint32_t tmp2[4];
	tmp1[0] = le32dec(&in[0x0]);
	tmp1[1] = le32dec(&in[0x4]);
	tmp1[2] = le32dec(&in[0x8]);
	tmp1[3] = le32dec(&in[0xC]);
	for (size_t i = 0; i < 31; ++i)
	{
		tmp1[0] ^= ctx->k[i][0];
		tmp1[1] ^= ctx->k[i][1];
		tmp1[2] ^= ctx->k[i][2];
		tmp1[3] ^= ctx->k[i][3];
		substitute(tmp2, tmp1, sbox[i % 8]);
		tmp1[0] = rol32(tmp2[0], 13);
		tmp1[2] = rol32(tmp2[2], 3);
		tmp1[1] = tmp2[1] ^ tmp1[0] ^ tmp1[2];
		tmp1[3] = tmp2[3] ^ tmp1[2] ^ (tmp1[0] << 3);
		tmp1[1] = rol32(tmp1[1], 1);
		tmp1[3] = rol32(tmp1[3], 7);
		tmp1[0] = tmp1[0] ^ tmp1[1] ^ tmp1[3];
		tmp1[2] = tmp1[2] ^ tmp1[3] ^ (tmp1[1] << 7);
		tmp1[0] = rol32(tmp1[0], 5);
		tmp1[2] = rol32(tmp1[2], 22);
	}
	tmp1[0] ^= ctx->k[31][0];
	tmp1[1] ^= ctx->k[31][1];
	tmp1[2] ^= ctx->k[31][2];
	tmp1[3] ^= ctx->k[31][3];
	substitute(tmp2, tmp1, sbox[31 % 8]);
	le32enc(&out[0x0], tmp2[0] ^ ctx->k[32][0]);
	le32enc(&out[0x4], tmp2[1] ^ ctx->k[32][1]);
	le32enc(&out[0x8], tmp2[2] ^ ctx->k[32][2]);
	le32enc(&out[0xC], tmp2[3] ^ ctx->k[32][3]);
}

void serpent_decrypt(struct serpent_ctx *ctx, uint8_t *out, const uint8_t *in)
{
	uint32_t tmp1[4];
	uint32_t tmp2[4];
	tmp1[0] = le32dec(&in[0x0]) ^ ctx->k[32][0];
	tmp1[1] = le32dec(&in[0x4]) ^ ctx->k[32][1];
	tmp1[2] = le32dec(&in[0x8]) ^ ctx->k[32][2];
	tmp1[3] = le32dec(&in[0xC]) ^ ctx->k[32][3];
	substitute(tmp2, tmp1, inv_sbox[31 % 8]);
	tmp2[0] ^= ctx->k[31][0];
	tmp2[1] ^= ctx->k[31][1];
	tmp2[2] ^= ctx->k[31][2];
	tmp2[3] ^= ctx->k[31][3];
	for (int i = 30; i >= 0; --i)
	{
		tmp1[2] = ror32(tmp2[2], 22);
		tmp1[0] = ror32(tmp2[0], 5);
		tmp1[2] = tmp1[2] ^ tmp2[3] ^ (tmp2[1] << 7);
		tmp1[0] = tmp1[0] ^ tmp2[1] ^ tmp2[3];
		tmp1[3] = ror32(tmp2[3], 7);
		tmp1[1] = ror32(tmp2[1], 1);
		tmp1[3] = tmp1[3] ^ tmp1[2] ^ (tmp1[0] << 3);
		tmp1[1] = tmp1[1] ^ tmp1[0] ^ tmp1[2];
		tmp1[2] = ror32(tmp1[2], 3);
		tmp1[0] = ror32(tmp1[0], 13);
		substitute(tmp2, tmp1, inv_sbox[i % 8]);
		tmp2[0] ^= ctx->k[i][0];
		tmp2[1] ^= ctx->k[i][1];
		tmp2[2] ^= ctx->k[i][2];
		tmp2[3] ^= ctx->k[i][3];
	}
	le32enc(&out[0x0], tmp2[0]);
	le32enc(&out[0x4], tmp2[1]);
	le32enc(&out[0x8], tmp2[2]);
	le32enc(&out[0xC], tmp2[3]);
}

void serpent_keyschedule(struct serpent_ctx *ctx, const uint8_t *key,
                         uint8_t len)
{
	uint32_t w[140];
	if (len == 16)
	{
		for (size_t i = 0; i < 4; ++i)
			w[i] = le32dec(&key[i * 4]);
		w[4] = 0x80000000;
		w[5] = 0;
		w[6] = 0;
		w[7] = 0;
	}
	else if (len == 24)
	{
		for (size_t i = 0; i < 6; ++i)
			w[i] = le32dec(&key[i * 4]);
		w[6] = 0x80000000;
		w[7] = 0;
	}
	else if (len == 32)
	{
		for (size_t i = 0; i < 8; ++i)
			w[i] = le32dec(&key[i * 4]);
	}
	for (size_t i = 0; i < 132; ++i)
	{
		w[i + 8] = rol32(w[i + 0]
		               ^ w[i + 3]
		               ^ w[i + 5]
		               ^ w[i + 7]
		               ^ 0x9E3779B9
		               ^ i, 11);
	}
	for (size_t i = 0; i < 33; ++i)
		substitute(ctx->k[i], &w[i * 4 + 8], sbox[(35 - i) % 8]);
}
