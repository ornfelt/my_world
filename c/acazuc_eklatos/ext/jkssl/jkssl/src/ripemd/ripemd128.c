#include "ripemd/ripemd.h"
#include "utils/utils.h"

#include <string.h>

static const uint8_t g[128] =
{
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
	0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
	0x7, 0x4, 0xD, 0x1, 0xA, 0x6, 0xF, 0x3,
	0xC, 0x0, 0x9, 0x5, 0x2, 0xE, 0xB, 0x8,
	0x3, 0xA, 0xE, 0x4, 0x9, 0xF, 0x8, 0x1,
	0x2, 0x7, 0x0, 0x6, 0xD, 0xB, 0x5, 0xC,
	0x1, 0x9, 0xB, 0xA, 0x0, 0x8, 0xC, 0x4,
	0xD, 0x3, 0x7, 0xF, 0xE, 0x5, 0x6, 0x2,
	0x5, 0xE, 0x7, 0x0, 0x9, 0x2, 0xB, 0x4,
	0xD, 0x6, 0xF, 0x8, 0x1, 0xA, 0x3, 0xC,
	0x6, 0xB, 0x3, 0x7, 0x0, 0xD, 0x5, 0xA,
	0xE, 0xF, 0x8, 0xC, 0x4, 0x9, 0x1, 0x2,
	0xF, 0x5, 0x1, 0x3, 0x7, 0xE, 0x6, 0x9,
	0xB, 0x8, 0xC, 0x2, 0xA, 0x0, 0x4, 0xD,
	0x8, 0x6, 0x4, 0x1, 0x3, 0xB, 0xF, 0x0,
	0x5, 0xC, 0x2, 0xD, 0x9, 0x7, 0xA, 0xE,
};

static const uint8_t s[128] =
{
	0xB, 0xE, 0xF, 0xC, 0x5, 0x8, 0x7, 0x9,
	0xB, 0xD, 0xE, 0xF, 0x6, 0x7, 0x9, 0x8,
	0x7, 0x6, 0x8, 0xD, 0xB, 0x9, 0x7, 0xF,
	0x7, 0xC, 0xF, 0x9, 0xB, 0x7, 0xD, 0xC,
	0xB, 0xD, 0x6, 0x7, 0xE, 0x9, 0xD, 0xF,
	0xE, 0x8, 0xD, 0x6, 0x5, 0xC, 0x7, 0x5,
	0xB, 0xC, 0xE, 0xF, 0xE, 0xF, 0x9, 0x8,
	0x9, 0xE, 0x5, 0x6, 0x8, 0x6, 0x5, 0xC,
	0x8, 0x9, 0x9, 0xB, 0xD, 0xF, 0xF, 0x5,
	0x7, 0x7, 0x8, 0xB, 0xE, 0xE, 0xC, 0x6,
	0x9, 0xD, 0xF, 0x7, 0xC, 0x8, 0x9, 0xB,
	0x7, 0x7, 0xC, 0x7, 0x6, 0xF, 0xD, 0xB,
	0x9, 0x7, 0xF, 0xB, 0x8, 0x6, 0x6, 0xE,
	0xC, 0xD, 0x5, 0xE, 0xD, 0xD, 0x7, 0x5,
	0xF, 0x5, 0x8, 0xB, 0xE, 0xE, 0x6, 0xE,
	0x6, 0x9, 0xC, 0x9, 0xC, 0x5, 0xF, 0x8,
};

static const uint32_t k[8] =
{
	0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC,
	0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x00000000,
};

#define ROUND(data, i, tmp, ofs, fv) \
do \
{ \
	uint32_t f = (fv) + k[((ofs) ? 64 + (i) : (i)) / 16]; \
	f += (tmp)[0]; \
	f += le32dec(&data[g[(ofs) ? 64 + (i) : (i)] * 4]); \
	f = rol32(f, s[(ofs) ? 64 + (i) : (i)]); \
	(tmp)[0] = (tmp)[3]; \
	(tmp)[3] = (tmp)[2]; \
	(tmp)[2] = (tmp)[1]; \
	(tmp)[1] = f; \
} while (0)

#define ROUND1(data, i, tmp, ofs) ROUND(data, i, tmp, ofs, (tmp)[1] ^ (tmp)[2] ^ (tmp)[3])
#define ROUND2(data, i, tmp, ofs) ROUND(data, i, tmp, ofs, ((tmp)[1] & (tmp)[2]) | ((~(tmp)[1]) & (tmp)[3]))
#define ROUND3(data, i, tmp, ofs) ROUND(data, i, tmp, ofs, ((tmp)[1] | (~(tmp)[2])) ^ (tmp)[3])
#define ROUND4(data, i, tmp, ofs) ROUND(data, i, tmp, ofs, ((tmp)[1] & (tmp)[3]) | ((tmp)[2] & (~(tmp)[3])))

#define ROUND14(data, i, tmp) \
do \
{ \
	ROUND1(data, i, &(tmp)[0], 0); \
	ROUND4(data, i, &(tmp)[4], 1); \
} while (0)
#define ROUND23(data, i, tmp) \
do \
{ \
	ROUND2(data, i, &(tmp)[0], 0); \
	ROUND3(data, i, &(tmp)[4], 1); \
} while (0)
#define ROUND32(data, i, tmp) \
do \
{ \
	ROUND3(data, i, &(tmp)[0], 0); \
	ROUND2(data, i, &(tmp)[4], 1); \
} while (0)
#define ROUND41(data, i, tmp) \
do \
{ \
	ROUND4(data, i, &(tmp)[0], 0); \
	ROUND1(data, i, &(tmp)[4], 1); \
} while (0)

static void chunk(struct ripemd128_ctx *ctx, const uint8_t *data)
{
	uint32_t tmp[8];

	for (int i = 0; i < 4; ++i)
	{
		tmp[i + 0] = ctx->h[i];
		tmp[i + 4] = ctx->h[i];
	}

	ROUND14(data, 0x00, tmp);
	ROUND14(data, 0x01, tmp);
	ROUND14(data, 0x02, tmp);
	ROUND14(data, 0x03, tmp);
	ROUND14(data, 0x04, tmp);
	ROUND14(data, 0x05, tmp);
	ROUND14(data, 0x06, tmp);
	ROUND14(data, 0x07, tmp);
	ROUND14(data, 0x08, tmp);
	ROUND14(data, 0x09, tmp);
	ROUND14(data, 0x0A, tmp);
	ROUND14(data, 0x0B, tmp);
	ROUND14(data, 0x0C, tmp);
	ROUND14(data, 0x0D, tmp);
	ROUND14(data, 0x0E, tmp);
	ROUND14(data, 0x0F, tmp);
	ROUND23(data, 0x10, tmp);
	ROUND23(data, 0x11, tmp);
	ROUND23(data, 0x12, tmp);
	ROUND23(data, 0x13, tmp);
	ROUND23(data, 0x14, tmp);
	ROUND23(data, 0x15, tmp);
	ROUND23(data, 0x16, tmp);
	ROUND23(data, 0x17, tmp);
	ROUND23(data, 0x18, tmp);
	ROUND23(data, 0x19, tmp);
	ROUND23(data, 0x1A, tmp);
	ROUND23(data, 0x1B, tmp);
	ROUND23(data, 0x1C, tmp);
	ROUND23(data, 0x1D, tmp);
	ROUND23(data, 0x1E, tmp);
	ROUND23(data, 0x1F, tmp);
	ROUND32(data, 0x20, tmp);
	ROUND32(data, 0x21, tmp);
	ROUND32(data, 0x22, tmp);
	ROUND32(data, 0x23, tmp);
	ROUND32(data, 0x24, tmp);
	ROUND32(data, 0x25, tmp);
	ROUND32(data, 0x26, tmp);
	ROUND32(data, 0x27, tmp);
	ROUND32(data, 0x28, tmp);
	ROUND32(data, 0x29, tmp);
	ROUND32(data, 0x2A, tmp);
	ROUND32(data, 0x2B, tmp);
	ROUND32(data, 0x2C, tmp);
	ROUND32(data, 0x2D, tmp);
	ROUND32(data, 0x2E, tmp);
	ROUND32(data, 0x2F, tmp);
	ROUND41(data, 0x30, tmp);
	ROUND41(data, 0x31, tmp);
	ROUND41(data, 0x32, tmp);
	ROUND41(data, 0x33, tmp);
	ROUND41(data, 0x34, tmp);
	ROUND41(data, 0x35, tmp);
	ROUND41(data, 0x36, tmp);
	ROUND41(data, 0x37, tmp);
	ROUND41(data, 0x38, tmp);
	ROUND41(data, 0x39, tmp);
	ROUND41(data, 0x3A, tmp);
	ROUND41(data, 0x3B, tmp);
	ROUND41(data, 0x3C, tmp);
	ROUND41(data, 0x3D, tmp);
	ROUND41(data, 0x3E, tmp);
	ROUND41(data, 0x3F, tmp);

	tmp[7] += ctx->h[1] + tmp[2];
	ctx->h[1] = ctx->h[2] + tmp[3] + tmp[4];
	ctx->h[2] = ctx->h[3] + tmp[0] + tmp[5];
	ctx->h[3] = ctx->h[0] + tmp[1] + tmp[6];
	ctx->h[0] = tmp[7];
}

int ripemd128_init(struct ripemd128_ctx *ctx)
{
	ctx->total_size = 0;
	ctx->data_size = 0;
	ctx->h[0] = 0x67452301;
	ctx->h[1] = 0xEFCDAB89;
	ctx->h[2] = 0x98BADCFE;
	ctx->h[3] = 0x10325476;
	return 1;
}

int ripemd128_update(struct ripemd128_ctx *ctx, const void *data, size_t size)
{
	HASH_BUFFERIZE(ctx, data, size, 64);
	return 1;
}

int ripemd128_final(uint8_t *md, struct ripemd128_ctx *ctx)
{
	MERKLE_DAMGARD_FINALIZE(ctx, 64, 0);
	for (int i = 0; i < 4; ++i)
		le32enc(&md[i * 4], ctx->h[i]);
	return 1;
}

int ripemd128(const uint8_t *data, size_t size, uint8_t *md)
{
	struct ripemd128_ctx ctx;
	if (!ripemd128_init(&ctx)
	 || !ripemd128_update(&ctx, data, size)
	 || !ripemd128_final(md, &ctx))
		return 0;
	return 1;
}
